// //reverse string
// const encrypt = (text) => {
//     let results = '';
//     for (let i = 0; i < text.length; i++) {
//     //   console.log(text.slice(i, i+2).split("").reverse().join(""));
//       results += text.slice(i, i+2).split("").reverse().join("");
//       i += 1;
//     }
//     return results;
// }
// console.log(encrypt('move')); // 'omev'
// console.log(encrypt('attack')); // 'taatkc'


/**
 * разбить массив на подстроки
 * пробежаться по ним поиском по нескольким условиям с циклом
 * если одно * или / - считаем, затем собираем заново собираем массив
 * !собираем массив не просто сбором, а вместо второго аргумента выражения, стоящего слева вносим результат (тут нужна функция, меняющая один элемент на другой и позвращающая полученную строку), и так везде
 * если несколько * или / - смотрим, у какого знака индекс меньше - выражение с этим знаком считаем первым - затем заново собираем массив и на новый круг
 * после всех операций с * и / тоже самое проделываем с + и -
 * цикл заканчивается тогда, когда в массиве длина будет равна 1
 */

// getSignIndexes('2+2+3-4');

// let str = '25+233*32-41*3\\2';


// let digitIndexRes = str.match(/\d+\*\d+/g);
// console.log(digitIndexRes);

/**
 * нужно используя параметры выше получать по очереди операционные выражения из строки
 * затем циклом получить из результаты и циклом в исходной строке заменить из значения результатом
 * затем повторить операцию с знаками идущими ниже по приоритету
 * пока строка не будет содержать одно число
 */

function barTriang(p1, p2, p3){
    let args = arguments;
    let x = 0;
    let y = 0; 

    for (key in args) {
        for ( let j = 0; j < args[key].length; j++ ){
            if ( j === 0 ) x += args[key][j];
            else if ( j === 1 ) y += args[key][j];
        }
    }

    let x0 = parseFloat((x / 3).toFixed(4));
    let y0 = parseFloat((y / 3).toFixed(4));

    let result = [x0, y0];
    return result;
}

console.log(barTriang([4, 6], [12, 4], [10, 10])); //------> [8.6667, 6.6667]